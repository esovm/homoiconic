%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% numbers       To obtain numeric citation style instead of author/year.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{amsmath,amsfonts}
\usepackage{url}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{amsthm}
\makeatletter
\def\th@definition{%
  \thm@notefont{}% same as heading font
  \normalfont % body font
}
\makeatother
\theoremstyle{definition}
\newtheorem{problem}{Problem}
\newtheorem{defn}{Definition}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{courier}
%\usepackage{pxfonts}
\usepackage{listings}
\lstset{
    %language=Haskell,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\bfseries\ttfamily\footnotesize,
    showstringspaces=false,
    %morekeywords={class,data,type,family,instance, where, ghci},
    morekeywords={ghci},
    %basicstyle=\footnotesize,
    literate={->}{{$\rightarrow$}}2 {>=}{{$\geq$}}2 {<-}{{$\leftarrow$}}2
             {<=}{{$\leq$}}2 {=>}{{$\Rightarrow$}}2
    %keywordstyle=\lst@ifdisplaystyle\color{blue}\fi,
    %commentstyle=\color{gray}
}
\lstMakeShortInline|

\newcommand{\cL}{{\cal L}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\homoiconic}{{\ttfamily homoiconic}~}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{filecontents}{paper.bib}
@article{goldberg1991,
  title={What every computer scientist should know about floating-point arithmetic},
  author={Goldberg, David},
  journal={ACM Computing Surveys (CSUR)},
  volume={23},
  number={1},
  pages={5--48},
  year={1991},
  publisher={ACM}
}

@inproceedings{jones2001playing,
  title={Playing by the rules: rewriting as a practical optimisation technique in GHC},
  author={Jones, Simon Peyton and Tolmach, Andrew and Hoare, Tony},
  booktitle={Haskell workshop},
  volume={1},
  pages={203--233},
  year={2001}
}

@book{higham2002,
  title={Accuracy and stability of numerical algorithms},
  author={Higham, Nicholas J},
  year={2002},
  publisher={Siam}
}

@article{swierstra2008,
  title={Data types {\`a} la carte},
  author={Swierstra, Wouter},
  journal={Journal of functional programming},
  volume={18},
  number={04},
  pages={423--436},
  year={2008},
  publisher={Cambridge Univ Press}
}

@inproceedings{schrijvers2009complete,
  title={Complete and decidable type inference for GADTs},
  author={Schrijvers, Tom and Peyton Jones, Simon and Sulzmann, Martin and Vytiniotis, Dimitrios},
  booktitle={ACM Sigplan Notices},
  volume={44},
  number={9},
  pages={341--352},
  year={2009},
  organization={ACM}
}

@book{hamming2012,
  title={Numerical methods for scientists and engineers},
  author={Hamming, Richard},
  year={2012},
  publisher={Courier Corporation}
}

@inproceedings{gupta2015,
  title={Deep Learning with Limited Numerical Precision},
  author={Gupta, Suyog and Agrawal, Ankur and Gopalakrishnan, Kailash and Narayanan, Pritish},
  booktitle={Proceedings of the 32nd International Conference on Machine Learning (ICML-15)},
  pages={1737--1746},
  year={2015}
}

@article{eisenberg2015promoting,
  title={Promoting functions to type families in Haskell},
  author={Eisenberg, Richard A and Stolarek, Jan},
  journal={ACM SIGPLAN Notices},
  volume={49},
  number={12},
  pages={95--106},
  year={2015},
  publisher={ACM}
}

@misc{viewpatterns,
  author = {GHC Wiki},
  title = {View patterns: lightweight views for Haskell},
  url = {https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns},
  note = {Accessed: 2016-06-09}
}

@misc{patternsynonyms,
  author = {GHC Wiki},
  title = {Pattern Synonyms},
  url = {https://ghc.haskell.org/trac/ghc/wiki/PatternSynonyms},
  note = {Accessed: 2016-06-09}
}
\end{filecontents}
\immediate\write18{bibtex paper}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country}
\copyrightyear{20yy}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\copyrightdoi{nnnnnnn.nnnnnnn}

% Uncomment the publication rights you want to use.
%\publicationrights{transferred}
%\publicationrights{licensed}     % this is the default
%\publicationrights{author-pays}

\titlebanner{Preprint}        % These are ignored unless
\preprintfooter{Preprint}   % 'preprint' option specified.

%\title{What's the point of homoiconicity?}
%\title{The (floating) point of homoiconicity}
\title{Homoiconicity Without Template Haskell}
\subtitle{Functional Pearl}

\authorinfo{Mike Izbicki}
           {UC Riverside}
           {mike@izbicki.me}
%\authorinfo{Name2\and Name3}
           %{Affiliation2/3}
           %{Email2/3}

\maketitle

\begin{abstract}
We say a function is \emph{homoiconic} if it can be converted into an isomorphic abstract syntax tree (AST).
This AST can then be manipulated arbitrarily and converted back into a function.
Template Haskell gives a \emph{compile time} form of homoiconicity to Haskell programs;
but in this pearl, we demonstrate another form of homoiconicity that relies on polymorphism and GHC's type programming capabilities.
To motivate our technique,
we construct a small library that automatically transforms numerically unstable code into stable code.

%This pearl shows that many Haskell functions are \emph{homoiconic}.
%That is, we can convert these functions into isomorphic abstract syntax trees (ASTs),
%and these ASTs can be converted back into their original Haskell functions.
%%These ASTs are ordinary Haskell data types,
%%so they can be manipulated arbitrarily to perform program transformations.
%The construction does not require template Haskell,
%and so works on expressions available at either compile or run time.
%To motivate this homoiconicity,
%we construct a small library that automatically transforms numerically unstable code into stable code.

%Floating point numbers are dangerous.
%Due to their limited precision,
%seemingly correct mathematical formulae can give wildly inaccurate results.
%This pearl shows that Haskell's type system can mitigate this danger.
%
%The main observation is that many numerical Haskell functions are \emph{homoiconic}.
%That is, we can easily convert them into isomorphic abstract syntax trees (ASTs).
%The construction does not use template Haskell, and so works at both compile and run time.
%We will use these ASTs to solve two problems with floating point numbers:
%\begin{enumerate}
%\item
%We will write higher order functions that automatically stabilize (or optimize!) mathematical formulae.
%%This lets one programmer write naive floating point code;
%%then an expert on numerical analysis can write code that automatically improves the naive code.
%\item
%We will specify type class laws for floating point arithmetic that can be automatically tested.
%Existing test frameworks do not work on floating point numbers because floats do not obey many traditional algebraic laws like associativity.
%\end{enumerate}
%We demonstrate these techniques using GHC's built-in numeric class hierarchy,
%but these techniques generalize to user defined class hierarchies as well.
\end{abstract}

%\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore,
% you may leave them out
%\terms
%term1, term2

%\keywords
%floating point, homoiconic, type classes

\section{Introduction}

%Imagine you've just downloaded and installed a machine learning library for Haskell.
%You open up ghci and import the corresponding modules.
%In the documentation, you see a function called |logLogistic|,
%so you ask ghci its type.
%\begin{lstlisting}
%ghci> :t logLogistic
%logLogistic :: Floating a => a -> a
%\end{lstlisting}
%Now imagine you want to know how the function is implemented.
%\begin{lstlisting}
%ghci> logLogistic var1 :: AST Floating Var
%\end{lstlisting}
%Oh no!
%The |logLogistic| function has a numerical instability in it.

Imagine you're writing a machine learning library in Haskell.
At some point, you'll need to implement the log-logistic function
\begin{equation}
f(x) = \log\left(\frac{1}{1+\exp{(-x)}}\right)
\label{eq:log-logistic}
\end{equation}
This function is used in logistic regression and many families of neural networks.
As a first attempt, you might write:
\begin{lstlisting}
logLogistic1 :: Floating x => x -> x
logLogistic1 x = log(1/(1+exp(-x)))
\end{lstlisting}
Unfortunately, this straightforward implementation is numerically unstable.
When specialized to the |Double| type,
the |exp| function overflows to infinity for inputs greater than (approximately) $709$.
%This overflow causes |logLogistic| to take the |log| of 0, which is undefined.
Therefore, on an input of $-710$,
|logLogisitic| will take the |log| of 0,
returning negative infinity when the true answer is actually very close to $-710$.
Such an inaccurate answer is unacceptable,
so the function must be rewritten.

But like all good programmers, you're lazy.
Your machine learning library will contain hundreds of numeric functions,
all of which will need to be carefully written to avoid numeric instabilities.
What a maintenance nightmare!
Soon you start daydreaming about a function
\begin{lstlisting}
stabilize :: Floating a => (a -> a) -> (a -> a)
\end{lstlisting}
that takes a naively written floating point function as input and outputs a numerically stable version.
Armed with such a function, you could write a stable implementation of the log-logistic function as
\begin{lstlisting}
logLogistic2 :: Floating x => x -> x
logLogistic2 x = stabilize $ log(1/(1+exp(-x)))
\end{lstlisting}
%stopzone

In this pearl, we see how to write functions like |stabilize| that perform program transformations.
These functions follow the following pattern.
First, convert the input function into an abstract syntax tree (AST).
Next, manipulate the AST to remove the numerical instabilities.
Finally, convert the AST back into a callable function.
%The key observation is that certain Haskell functions are \emph{homoiconic}.
%That is, we can convert them into isomorphic abstract syntax trees (ASTs).
%The key observation is that certain Haskell functions (which we call \emph{homogeneous} and \emph{heterogeneous}) can be converted into equivalent abstract syntax trees (ASTs).
%The |stabilize| function converts its input function into an AST,
%then manipulate that AST to remove numerical stabilities,
%and finally convert the AST back into a callable function.

The main idea of the |homoiconic| library is that we can associate with every type class an FAlgebra that captures the algebraic structure of that class.

In Section \ref{sec:homogeneous},
%In Section \ref{sec:homogeneous}, we introduce the idea of a \emph{homogeneous} function and show that these functions are homoiconic.
%In Section \ref{sec:stabilize}, we use the construction above to implement several versions of the |stabilize| function.
%In Section \ref{sec:heterogeneous}, we introduce the idea of \emph{heterogeneous} functions and show that they are also homoiconic.
%Finally, we conclude by introducing a Haskell package called {\ttfamily homoiconic} that makes it easy for you to .

\section{Homogeneous functions are homoiconic}
\label{sec:homogeneous}

In this section we first define homogeneous type classes and functions.
There are two intuitions for homogeneous type classes.
First, they have ASTs that contain only a single type variable.
Second, we can construct an FAlgebra for these type classes.

\begin{defn}
We call a type class homogeneous if:
\begin{enumerate}
\item
it has a single parameter of kind |Type|; and
\item
the class's constraints contain only homogeneous type classes applied directly to the parameter.
\end{enumerate}
For example, all of the classes in the Prelude are homogeneous.
Some of these classes are shown in Figure \ref{code:ghc}.
Figure 2 (near the end of the paper) shows type classes which are not homogeneous due to the presence of type families in the constraints.
\end{defn}

\begin{defn}
We call a function homogeneous if:
\begin{enumerate}
\item
there is exactly one type variable in the signature, which we denote by |a|;
\item
each of the function's parameters is either
\begin{enumerate}
\item
|a|, or
\item
concrete;
\end{enumerate}
\item
the function's return type is |a|; and
\item
the constraints contain only homogeneous type classes applied to |a|.
\end{enumerate}
The |logLogistic1| function is homogeneous,
and Figure \ref{code:ghc} shows many more examples taken from the Prelude's numeric hierarchy.
\end{defn}

%In this section, we will show that every type class has an associated monad representing the abstract syntax tree of the class's homogeneous functions.
%Our construction is closely related to other constructions involving initial algebras, FAlgebras, and free monads.
%See for example \cite{swierstra2008}.

%Our goal in this section is to convert homogeneous functions into ASTs.
%These ASTs will contain only a single parameter type, and so are relatively simple.
%The construction will use FAlgebras\cite{swierstra2008}.

\begin{figure}
\begin{lstlisting}
class Num a where
    (+), (-), (*)       :: a -> a -> a
    negate              :: a -> a
    abs, signum         :: a -> a
    fromInteger         :: Integer -> a

class Num a => Fractional a where
    (/)                 :: a -> a -> a
    recip               :: a -> a
    fromRational        :: Rational -> a

class Fractional a => Floating a where
    pi                  :: a
    exp, log, sqrt      :: a -> a
    (**), logBase       :: a -> a -> a
    sin, cos, tan       :: a -> a
    asin, acos, atan    :: a -> a
    sinh, cosh, tanh    :: a -> a
    asinh, acosh, atanh :: a -> a

class Eq a where
    (==), (/=)          :: a -> a -> Bool

class Eq a => Ord a where
    compare             :: a -> a -> Ordering
    (<),(<=),(>),(>=)   :: a -> a -> Bool
    max, min            :: a -> a -> a
\end{lstlisting}
\caption{
    A portion of the numeric and comparison hierarchies defined in GHC's Prelude.
    %Functions highlighted in bold are homogeneous,
    %and the remainder are not.
}
\label{code:ghc}
\end{figure}


\subsection{A type class for FAlgebras}
Every homogeneous type class has an associated FAlgebra.
We represent this FAlgebra with the following type class.
\begin{lstlisting}
class Functor (Sig alg) => FAlgebra alg where
    data Sig alg a
    runSig :: alg a => Sig alg a -> a
\end{lstlisting}
The |FAlgebra| class is unusual in that its parameter has kind |Type->Constraint|.
This means that instances of |FAlgebra| will be other type classes
(instead of types or type constructors).

It is easiest to understand the |FAlgebra| class by walking through an example instance.
Below is the instance for |Fractional|.
\begin{lstlisting}
instance FAlgebra Fractional where
    data Sig Fractional a
        = Sig_div a a
        | Sig_recip a
        | Sig_fromRational Rational
        | Sig_Fractional_Num (Sig Num a)
    runSig (Sig_div a1 a2)        = a1/a2
    runSig (Sig_recip a)          = recip a
    runSig (Sig_fromRational r)   = fromRational r
    runSig (Sig_Fractional_Num s) = runSig s
\end{lstlisting}

The data family |Sig| encodes what mathematicians call the \emph{signature} of the FAlgebra.
The signature defines all the operations that can be performed on an FAlgebra.
Each |Sig| data instance can have many constructors,
and these constructors come in two flavors.
First is the \emph{function constructor}.
There should be one function constructor for each homogeneous class function, and
this constructor should have the same parameters as the function.
For the |Fractional| example, we've defined the three constructors |Sig_div|, |Sig_recip|, and |Sig_fromRational| for the three member functions |(/)|, |recip|, and |fromRational| respectively.
The second constructor flavor is the \emph{superclass constructor}.
There should be one superclass constructor for each superclass, and
this constructor should store the |Sig| of the corresponding superclass.
For the |Fractional| example, we have the |Sig_Fractional_Num| constructor corresponding to the |Num| superclass.

The |runSig| class method evaluates an FAlgebra's signature.
Mathematicians sometimes call this function simply an \emph{algebra}.
For each function constructor, |runSig| should call the corresponding function.
For each superclass constructor, |runSig| recursively calls |runSig| on the superclass's |Sig|.
This is exactly what the |Fractional| instance above does.

The F in FAlgebra comes from the fact that every signature is actually a functor.
In Haskell, we encode this by enforcing that |Sig alg| must be an instance of the |Functor| class.
As usual, there is only a single valid |Functor| instance.
For |Fractional|, it is:
\begin{lstlisting}
instance Functor (Sig Fractional) where
    fmap f (Sig_div a1 a2) = Sig_div (f a1) (f a2)
    fmap f (Sig_recip a) = Sig_recip (f a)
    fmap f (Sig_fromRational r) = Sig_fromRational r
    fmap f (Sig_Fractional_Num s) = fmap f s
\end{lstlisting}

\subsection{Constructing the AST}

For every FAlgebra, there is an associated AST.
This AST is sometimes called an \emph{initial algebra},
and has a standard construction via the \emph{free monad}.
In Haskell, the free monad is defined as
\begin{lstlisting}
data Free f a
    = Pure a
    | Free (f (Free f a))
\end{lstlisting}
which lets us define our AST as
\begin{lstlisting}
type AST alg a = Free (Sig alg) a
\end{lstlisting}
Intuitively,
the |Pure| constructor represents a leaf in the AST,
and the |Free| constructor represents a branch.
The parameter to |Free| is filled by the appropriate |Sig| data instance.
The constructor used for the |Sig| instance corresponds to an operation,
and the parameters to the constructor will contain ASTs nested recursively.

For example, consider the expression |(1+2)+3|.
We can create a corresponding AST using |Num|'s |FAlgebra| instance.
\begin{lstlisting}
expr1 :: AST Num Double
expr1 = Free
  (Sig_plus
    (Free
      (Sig_plus
        (Pure 1)
        (Pure 2)
      )
    )
    (Pure 3)
  )
\end{lstlisting}
The type signature is not necessary, but shown for clarity.

We can also create an AST for the same expression using any subclass of |Num|.
Below is the same expression encoded using |Floating|'s |FAlgebra| instance.
\begin{lstlisting}
expr2 :: AST Floating Double
expr2 = Free
  (Sig_Floating_Fractional
    (Sig_Fractional_Num
      (Sig_plus
        (Free
          (Sig_Floating_Fractional
            (Sig_Fractional_Num
              (Sig_plus
                (Pure 1)
                (Pure 2)
              )
            )
          )
        )
        (Pure 3)
      )
    )
  )
\end{lstlisting}
Notice that the |Sig_plus| constructor must be embedded into |Floating|'s |Sig| with calls to |Sig_Floating_Fractional| and |Sig_Fractional_Num|.
These embeddings create considerable boilerplate,
making the construction of ASTs by hand a tedious process.

We can avoid this boilerplate with a type class that performs these embeddings for us.\footnote{
    The name {\ttfamily View} stems from the fact that the class methods are actually what GHC calls ``view patterns.''
    See Section \ref{sec:viewpatterns} for details on how the {\ttfamily ViewPatterns} language extension lets us use the {\ttfamily View} type class for easier pattern matching on our ASTs.
}
\begin{lstlisting}
class (FAlgebra alg1, FAlgebra alg2)
    => View alg1 alg2 where
    embedSig         :: Sig alg1 a -> Sig alg2 a
    unsafeExtractSig :: Sig alg2 a -> Sig alg1 a
\end{lstlisting}
Instances of |View| should satisfy the property that |alg1| is either equal to |alg2| or is a superclass of |alg2|, and
all such relationships should have a corresponding instance.
This property ensures that the |Sig alg1 a| data instance can always be embedded into a |Sig alg2 a| data instance (via a chain of superclass constructors).
It is only sometimes true that we can extract a |Sig alg1 a| from a |Sig alg2 a|,
so the function is partial and hence labeled |unsafe|.
For example,
we have the following |View Num Floating| instance because |Num| is a superclass of |Floating| via |Fractional|.
\begin{lstlisting}
instance View Num Floating
    embedSig s
        = Sig_Fractional_Floating (embedSig s)
    unsafeExtractSig (Sig_Fractional_Floating s)
        = unsafeExtractSig s
\end{lstlisting}
The |embedSig| function shows us how to embed a |Sig Num| into a |Sig Floating| by calling the appropriate superclass constructors.
Notice that the recursive call to |embedSig| relies on a |View Num Fractional| instance also existing.
Similarly, the |unsafeExtractSig| function extracts the |Sig Num| instance by pattern matching on the appropriate superclass constructors.

Armed with this |View| class, we can create a uniform representation for |FAlgebra|'s ASTs.
The expression |(1+2)+3| can now be represented polymorphically as:
\begin{lstlisting}
expr3 :: View Floating alg => AST alg Double
expr3 = Free
  (embedSig
    (Sig_plus
      (Free
        (embedSig
          (Sig_plus
            (Pure 1)
            (Pure 2)
          )
        )
      )
      (Pure 3)
    )
  )
\end{lstlisting}

Using our uniform representation of an AST,
we can make the |AST| type an instance of the homogeneous type classes.
As an example, the |Fractional| instance is shown below.
\begin{lstlisting}
instance View Fractional alg
    => Fractional (AST alg a) where
    (/) e1 e2 = Free $ embedSig $ Sig_div e1 e2
    recip e   = Free $ embedSig $ Sig_recip e
    fromRational r
        = Free $ embedSig $ Sig_fromRational r
\end{lstlisting}
For each function in the type class,
we simply embed the function's constructor into the AST by prepending the expression |Free $ embedSig $|.

We can easily create ASTs using these instances.
The |Num| AST can be created with the expression
\begin{lstlisting}
expr4 :: AST Num Double
expr4 = (1+2)+3
\end{lstlisting}
And the |Floating| AST can be created by just changing the type signature.
\begin{lstlisting}
expr5 = AST Floating Double
expr5 = (1+2)+3
\end{lstlisting}
Notice that in these last two examples we did not embed the numbers into the AST with the |Pure| constructor.
Since |AST| is an instance of |Num|,
GHC will call |fromInteger| to embed the number for us automatically.

\subsection{Showing the AST}
Now that we can create our ASTs, we want to actually do something with them!
In this section we will convert them into a |String| for display.
This is an easy procedure of writing |Show| instances for the |Sig| and |Free| data types.

There are no tricks in the |Show| instance for |Sig|.
The instance for |Fractional| is shown below.
\begin{lstlisting}
instance Show a => Show (Sig Fractional a) where
    show (Sig_div a1 a2) = show a1++"/"++show a2
    show (Sig_recip a) = "recip "++show a
    show (Sig_fromRational r) = "fromRational "++show r
    show (Sig_Fractional_Num s) = show s
\end{lstlisting}
For each function constructor, we simply show the corresponding function and its parameters.
If the function is an operator, we'll display it infix for convenience.
For each superclass constructor, we simply recursively call show on the superclass's |Sig|.

The |Free| type's |Show| instance is similarly straightforward.
\begin{lstlisting}
instance (Show a, Show (f (Free f a)))
    => Show (Free f a) where
    show (Pure a) = show a
    show (Free f) = "("++show f++")"
\end{lstlisting}
If the syntax tree contains only a single leaf, we just show that leaf.
If the syntax tree contains a branch,
then put parenthesis around the branch,
and show the functor (i.e. the |Sig|) in the middle.

Now, when we type a numeric expression into ghci without a type signature,
ghci will evaluate the expression like normal.
\begin{lstlisting}
ghci> (1+2)+3
6
\end{lstlisting}
But when we add the appropriate type signature,
the full AST is displayed.
\begin{lstlisting}
ghci> (1+2)+3 :: AST Floating Double
(((fromInteger 1)+(fromInteger 2))+(fromInteger 3))
\end{lstlisting}
Again, the way ghci works, all integer literals automatically have |fromInteger| applied to them,
which is why this function appears in the AST above.
It would be easy to create a pretty printer that does not display |fromInteger| or the excess parentheses,
but this is left as an exercise for the reader.

\subsection{Showing functions}
Reconsider our |logLogistic1| function.
It has type
\begin{lstlisting}
logLogistic1 :: Floating a => a -> a
\end{lstlisting}
What happens if we specialize the |a| parameter to |AST Floating Double|?
We get a peek at the function's internals.
\begin{lstlisting}
ghci> logLogistic1 1 :: AST Floating Double
(log ((fromInteger 1)/((fromInteger 1)+(exp
    (negate (fromInteger 1))))))
\end{lstlisting}
We don't just have to input single numbers;
we can also input full expressions.
These expressions will also get displayed,
intermixed with the original function.
\begin{lstlisting}
ghci> logLogistic1 (1*3+4) :: AST Floating Double
(log ((fromInteger 1)/((fromInteger 1)+(exp
    (negate (((fromInteger 1)*(fromInteger 3))
    +(fromInteger 4)))))))
\end{lstlisting}
And we can even display the resulting AST of nested function calls.
\begin{lstlisting}
ghci> logLogistic1 (logLogistic1 1)
    :: AST Floating Double
(log ((fromInteger 1)/((fromInteger 1)+(exp
    (negate (log ((fromInteger 1)/((fromInteger 1)
    +(exp (negate (fromInteger 1)))))))))))
\end{lstlisting}
It would be nice if the displayed function would display the actual input variables,
rather than just substituting numbers.
To accomplish this, we need a variable type.
\begin{lstlisting}
newtype Var = Var String
\end{lstlisting}
Values of type |Var| cannot be plugged directly into the |logLogistic1| function because |Var| is not an instance of |Floating|.
Fortunately, we have a way to make any type an instance of |Floating| via the |AST Floating| type.
More generically, we define the following variables.
\begin{lstlisting}
var1 :: AST alg Var
var1 = Pure "var1"

var2 :: AST alg Var
var2 = Pure "var2"

var3 :: AST alg Var
var3 = Pure "var3"
\end{lstlisting}
And we can use them to recover the exact AST of a function.
\begin{lstlisting}
ghci> logLogistic1 var1 :: AST Floating Var
(log ((fromInteger 1)/((fromInteger 1)+(exp
    (negate var1)))))
\end{lstlisting}
At this point, you might be tempted to write a |Show| instance for functions.
\begin{lstlisting}
instance
    ( FAlgebra alg
    , Show (Sig alg (Free (Sig alg) Var))
    ) => Show (AST alg Var -> AST alg Var) where
    show f = show (f var1)
\end{lstlisting}
Unfortunately, if you try to use the instance naively
\begin{lstlisting}
ghci> logLogistic1
\end{lstlisting}
then ghci will complain about ambiguous type variables.
GHC's defaulting mechanism is not powerful enough for it to properly specialize the function without a type signature.
So unfortunately this technique doesn't give us a convenient |Show| instance,
it does give us a slightly more verbose alternative for showing a function.

\subsection{Evaluating the syntax tree}
Our last task is to evaluate the ASTs.
That is, we need to run them to generate the value the tree represents.

To do this, we will take advantage of the free monad's structure.
(Recall that the |AST| type we've been using is a synonym for the free monad.)
The free monad is so called because as long as the parameter |f| is a |Functor|,
then |Free| has a valid |Monad| instance.
Since all |Monad|s are by necessity also |Functor|s,
|Free| has a valid |Functor| instance as well.
\begin{lstlisting}
instance Functor f => Functor (Free f) where
    fmap g (Pure a) = Pure (g a)
    fmap g (Free f) = Free (fmap (fmap g) f)
\end{lstlisting}
For our purposes, that's all the structure we'll need.

The following simple function evaluates the syntax tree.
\begin{lstlisting}
runAST :: (FAlgebra alg, alg a) => AST alg a -> a
runAST (Pure a) = a
runAST (Free f) = runSig (fmap evalHom f)
\end{lstlisting}
If our syntax tree already consists of just a single value (i.e. it is the |Pure| constructor),
then we just return that value.
Otherwise, we use the |Functor| instance to recursively convert the |Sig|s into types of |a|,
combining the results with |runSig|.

When we evaluate an AST for an expression,
we get the same result as if we had just evaluated the expression directly.
\begin{lstlisting}
ghci> logLogistic1 10 :: Double
-4.539889921682063e-5

ghci> runAST (logLogistic1 10 :: AST Floating Double)
-4.539889921682063e-5
\end{lstlisting}
We've finally demonstrated that homogeneous functions are in fact homoiconic.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\section{Writing program transformations}
\label{sec:stabilize}

We're now ready to write program transformations that manipulate the ASTs.
The standard way to deconstruct an AST Haskell is via pattern matching.
In this section, we'll first demonstrate how to pattern match our ASTs using the |ViewPatterns| and |PatternSynonyms| language extensions.
Then we'll see three simple examples of program transformations implemented in this way.

%Automatically stabilizing floating point expressions is an active area of research.
%One way of doing this is to create a library of program transformations that fix many different types of expressions.
%Then combining everything in the library on your problem.
%In this section, we'll create a very small library for these floating point issues,
%and don't claim to have completely solved the floating point problem.
%This is simply a motivating example for homoiconicity.

\subsection{Pattern matching the AST}

Consider the following simple,
but numerically unstable function.
\begin{lstlisting}
testFunc1 :: Floating a => a -> a
testFunc1 = log (exp a)
\end{lstlisting}
As in our |logLogistic1| function, |testFunc| gives incorrect answers when specialized to |Double|.
Inputs greater than (approximately) 710 cause the |exp| function to overflow to infinity;
the log of infinity is still infinity;
so the returned answer is infinity.
But this wrong.
Mathematically, the $\log$ function is defined to be the inverse of $\exp$,
so the final result should be exactly the same as the input.
We'll write a program transformation that stabilizes the |testFunc1| function,
then we'll demonstrate how the |ViewPatterns| and |PatternSynonyms| language extensions simplify this transformation.
\label{sec:viewpatterns}

Our goal is to take in input AST,
find all occurrences of the expression |log (exp x)|,
and replace them with just |x|.
Here |x| can be an arbitrary subtree of the original AST.
We will create a series of four functions to accomplish this task,
each improving on the previous.
Here is the first.
\begin{lstlisting}
logexpAST1 :: AST Floating a -> AST Floating a
logexpAST1 (Free (Sig_log (Free (Sig_exp a)))) = a
\end{lstlisting}
This function has two syntactic warts.
First, the pattern is noisy.
To properly match the expression, we must alternate between the |Free| and |Sig_| constructors.
Second, the function is specialized to the |Floating| type class.
We would like our transformation to also works on subclasses of |Floating|.

We'll start by correcting the second problem using the |ViewPatterns| language extension.
|ViewPatterns| provides a syntactic sugar that lets us pattern match on the return value of a function.\footnote{
    The GHC wiki \cite{viewpatterns} provides details on exactly how the desugaring works.
}
We can use |ViewPatterns| to write polymorphic patterns by using polymorphic functions in the pattern.
Fortunately, we've already defined the exact function we need:
\begin{lstlisting}
unsafeExtractSig :: View alg1 alg2
    => Sig alg2 a -> Sig alg1 a
\end{lstlisting}
By using this function in the pattern,
we can write a polymorphic version of our program transformation.
\begin{lstlisting}
logexpAST2 :: View Floating alg
    => AST alg a -> AST alg a
logexpAST2
    (Free (unsafeExtractSig -> Sig_log
    (Free (unsafeExtractSig -> Sig_exp a))))
    = a
\end{lstlisting}
This function now has the correct type signature (so we've solved problem 2),
but the pattern matches are even uglier (so problem 1 is worse).

The |PatternSynonyms| extension lets us define new patterns,
and we will use this feature to clean up our syntax.\footnote{
    Again, see the GHC Wiki \cite{patternsynonyms} for details on this language extension.
}
Specifically, we define a pattern synonym for each function contained in an FAlgebra.
Our naming convention is to prefix |AST_| to the name of the function.
These pattern synonyms combine the |Free| constructor with the view pattern from the previous example.
The synonyms for the |log| and |exp| functions are shown below.
\begin{lstlisting}
pattern AST_log :: View Floating alg
    => AST alg a -> AST alg a
pattern AST_log e
    <- Free (unsafeExtractSig -> Sig_log e)

pattern AST_exp :: View Floating alg
    => AST alg a -> AST alg a
pattern AST_exp e
    <- Free (unsafeExtractSig -> Sig_exp e)
\end{lstlisting}
Armed with these pattern synonyms,
we can rewrite our function in a much simpler form.
\begin{lstlisting}
logexpAST3 :: View Floating alg
    => AST alg a -> AST alg a
logexpAST3 (AST_log (AST_exp a)) = a
\end{lstlisting}
This simple function works on our the motivating test case:
\begin{lstlisting}
ghci> logexpAST3 $ testFunc1 var1 :: AST Floating Var
var1
\end{lstlisting}
%stopzone
but it fails to work in this slightly more complex function:
\begin{lstlisting}
testFunc2 :: Floating a => a -> a
testFunc2 a = 1+exp(log a)
\end{lstlisting}
We haven't told our program transformations what to do when they don't pattern match!
The correct answer is that we want the transformations to recurse into the subexpressions,
applying the transformations there as well.
In the free monad, recursion is handled by a call to |fmap| and the base case is handled by extracting the value of |Pure|.
This gives our final version of the program transformation.
\begin{lstlisting}
logexpAST4 :: View Floating alg
    => AST alg a -> AST alg a
logexpAST4 (AST_log (AST_exp a)) = a
logexpAST4 (Free f) = Free (fmap logexpAST4 f)
logexpAST4 (Pure a) = Pure a
\end{lstlisting}
Now we correctly recurse into subexpressions.
\begin{lstlisting}
ghci> logexpAST4 $ testFunc2 var1
    :: AST Floating Var
((fromInteger 1)+var1)
\end{lstlisting}
%stopzone
There's still one last wrinkle.
What if we need to apply the program transformation multiple times?
Consider the following test function.
\begin{lstlisting}
testFunc3 :: Floating a => a -> a
testFunc3 a = 1+log(log(log(exp(exp(exp a)))))
\end{lstlisting}
Applying our program transformation directly doesn't fix the function because the transformation needs to be applied repeatedly.
\begin{lstlisting}
ghci> logexpAST4 $ testFunc3 var1
    :: AST Floating Var
((fromInteger 1)+(log (log (exp (exp var1)))))
\end{lstlisting}
%stopzone
What we want is the \emph{fixed point} of the program transformation.
That is, we want to apply the program transformation repeatedly until it stops changing the AST.
The |fixAST| function below takes as input a transformation and returns the fixed point of that transformation.
\begin{lstlisting}
fixAST ::
    ( Eq (Sig alg (Free (Sig alg) a))
    , Eq a
    ) => (AST alg a -> AST alg a)
      -> (AST alg a -> AST alg a)
fixAST f ast = if ast==ast'
    then ast
    else fixAST f ast'
    where
        ast' = f ast
\end{lstlisting}
Now we can correctly modify the |testFunc3| function.
\begin{lstlisting}
ghci> fixAST logexpAST4 $ testFunc3 var1
    :: AST Floating Var
((fromInteger 1)+var1)
\end{lstlisting}
%stopzone

\subsection{More complex transformations}

The transformation in in the previous section is relatively simple.
It could just as easily have been written using GHC's rewrite rules syntax \cite{jones2001playing}.
Rewrite rules are the primary mechanism for optimising source code in GHC.
One limitation of rewrite rules is that they cannot perform computations on the rewritten expression.
This limitation prevents rewrite rules from implementing the constant folding optimization.
Our program transformations, however, are powerful enough for this transformation.

The following function performs constant folding on expressions containing addition and multiplication of integers.
\begin{lstlisting}
foldConstants :: View Num alg
    => AST alg a -> AST alg a
foldConstants (AST_plus
    (AST_fromInteger a1)
    (AST_fromInteger a2))
    = AST_fromInteger (a1+a2)
foldConstants (AST_mul
    (AST_fromInteger a1)
    (AST_fromInteger a2))
    = AST_fromInteger (a1*a2)
foldConstants (Free sig)
    = Free (fmap foldConstants sig)
foldConstants (Pure a) = Pure a
\end{lstlisting}
It is straightforward to extend this function to work for other operations,
but for space reasons these were omitted.

Here's an example of our constant folding in action.
First define a simple function.
\begin{lstlisting}
constFunc :: Num a => a -> a -> a
constFunc x1 x2 = x1*2+(7+2)*x2
\end{lstlisting}
If we call this function with two known parameters,
our |foldConstants| function is able to simplify the expression into a single constant.
\begin{lstlisting}
ghci> fixAST foldConstants (constFunc 2 3)
    :: AST Floating Double
(fromInteger 31)
\end{lstlisting}
Alternatively, we can call the function with two variable parameters and only fold the constants in the expression.
\begin{lstlisting}
ghci> fixAST foldConstants (constFunc var1 var2)
    :: AST Floating Var
((var1*(fromInteger 2))+((fromInteger 9)*var2))
\end{lstlisting}
We can even invoke the function with one known and one variable parameter.
\begin{lstlisting}
ghci> fixAST foldConstants (constFunc var1 3)
    :: AST Floating Var
((var1*(fromInteger 2))+(fromInteger 27))
\end{lstlisting}

\subsection{The log-logistic function}

Our original motivation was to stabilize the |logLogistic1| function.
Stabilizing this function is a bit harder because it actually requires changing the type signature of the function by adding an |Ord| instance.
One of the requirements of a homogeneous function is that it have only a single class in the context.
To accommodate this condition, we'll create a new type class that has our desired types in the constraint.
\begin{lstlisting}
class (Floating a, Ord a) => FloatingOrd a
instance {-#OVERLAPPABLE#-} (Floating a, Ord a) => FloatingOrd a
\end{lstlisting}
Note that the |OVERLAPPABLE| pragma is required so that we can create an |Ord| instance for |AST FloatingOrd a|.

Now we can define our transformation as
\begin{lstlisting}
stabilize :: Eq a =>
    AST FloatingOrd a -> AST FloatingOrd a
stabilize
    (AST_log
        (AST_div
            (AST_fromInteger 1)
            (AST_plus
                (AST_fromInteger 1)
                (AST_exp
                    (AST_negate x)
                )
            )
        )
    )
    = m+log(1/(exp(m)+exp(-x+m)))
        where
            m = min 0 x
\end{lstlisting}

\section{Heterogeneous functions are homoiconic}

GHC's numerical class hierarchy is notoriously limited.
For example, GHC's numeric hierarchy has no notion of vectors.
Figure \ref{code:vector} shows a simple extension to the default hierarchy to incorporate vectors.

\begin{figure}
\begin{lstlisting}
type family Scalar a

class (Num a, Floating (Scalar a))
    => Vector a where
    (.*) :: Scalar a -> a -> a

class Vector a => Hilbert a where
    dotproduct :: a -> a -> Scalar a

data Vec3 = Vec3 a a a
type Scalar (Vec3 a) = a
\end{lstlisting}
\caption{
    A simple extension to GHC's numeric hierarchy for vector arithmetic.
    A vector space is a special type of number---{\ttfamily (+)} represents vector addition, and {\ttfamily (*)} represents elementwise multiplication---that has an associated {\ttfamily Scalar} type and the ability to perform scalar multiplication with {\ttfamily (.*)}.
    A Hilbert space is a vector space with dot products.
}
\label{code:vector}
\end{figure}

You can now implement the logistic loss as:
\begin{lstlisting}
logLoss :: Vector a => a -> a -> Scalar a
logLoss a1 a2 = logLogistic1 (dotproduct a1 a2)
\end{lstlisting}
Unfortunately, this function is not homogeneous due to the application of a type family in the return type.
So we cannot use the construction of Section \ref{sec:homogeneous} to generate an AST for this function.
In this section, we introduce the more general notion of heterogeneous type classes and functions.
These concepts are called heterogeneous because they allow the construction of ASTs over multiple types through the use of type families.

\begin{defn}
We call a type class heterogeneous if:
\begin{enumerate}
\item
it has a single parameter of kind |Type|; and
\item
the class's constraints contain only heterogeneous type classes applied either directly to the parameter \emph{or to a type family applied to a parameter}.
\end{enumerate}
For example, every homogeneous type class is also heterogeneous.
The type classes in Figure 2 are all heterogeneous, but not homogeneous.
\end{defn}

\begin{defn}
We call a function heterogeneous if:
\begin{enumerate}
\item
there is exactly one type variable in the signature, which we denote by |a|;
\item
each of the function's parameters is either
\begin{enumerate}
\item
|a|,
\item
concrete, or
\emph{
\item
a type family applied to }|a|;
\end{enumerate}
\item
the function's return type is either |a| \emph{or a type family applied to} |a|; and
\item
the constraints contain only heterogeneous type classes applied to |a| \emph{or type family applied to} |a|.
\end{enumerate}
All homogeneous functions are heterogeneous.
The |logLoss| function is heterogeneous but not homogeneous.
\end{defn}

The construction of ASTs follows for heterogeneous types follows a similar pattern as for homogeneous types, but involves considerably more type hackery.

\subsection{The problems of heterogeneous types}
Before discussing how to construct the heterogeneous ASTs,
we will look at three problems that type families introduce to the homogeneous AST construction.

\begin{problem}[the superclass problem]
Consider the |Vector| class in Figure \ref{code:vector}.
This class is not homogeneous because of the superclass constraint involving a type family application.
If we follow the formulation for making a homogeneous FAlgebra, we get
\begin{lstlisting}
instance FAlgebra Vector where
    data Sig Vector a
        = Sig_dotmul (Scalar a) a
        | Sig_Vector_Num (Sig Num a)
        | Sig_Vector_Floating (Sig Floating (Scalar a))
    runSig (Sig_dotmul s a) = s.* a
    runSig (Sig_Vector_Num s) = runSig s
    runSig (Sig_Vector_Floating s) = runSig s
\end{lstlisting}
This definition does not type check.
In the last line of |runSig|'s definition,
the type checker will try to match the |a| type with |Scalar a| and fail.
To fix this problem, we will need to modify the way we create superclass constructors.
\end{problem}

\begin{problem}[the parameter problem]
Now consider what happens when we write the |Functor| instance
\begin{lstlisting}
instance Functor (Sig Vector) where
    fmap f (Sig_dotmul s a) = Sig_dotmul (f s) (f a)
    fmap f (Sig_Vector_Num s) = Sig_Vector_Num (f s)
    fmap f (Sig_Vector_Floating s) = Sig_Vector_Floating (f s)
\end{lstlisting}
Here type checking fails on |fmap|'s first clause in the expression |f s|.
The function |f| has type |a -> b|, but the |s| variable has type |Scalar a|.
We can no longer map arbitrary functions over our |Sig| type.
To fix this problem, we will need a modified functor class.
\end{problem}

\begin{problem}[the return type problem]
Consider the |Hilbert| class in Figure \ref{code:vector}.
The |dotProduct| function is not homogeneous because of the type family in the return type.
If we follow the formulation for making a homogeneous FAlgebra, we get
\begin{lstlisting}
instance FAlgebra Hilbert where
    data Sig Hilbert a
        = Sig_Hilbert_Module (Sig Module a)
        | Sig_dotProduct a a
    runSig (Sig_Hilbert_Module s) = runSig s
    runSig (Sig_dotProduct a1 a2) = dotProduct a1 a2
\end{lstlisting}
Here, type checking fails in the last clause of |runSig|.
The return type should be |a|,
but |dotProduct| returns a |Scalar a|.
To fix this problem, we need to change the way we run a signature.
\end{problem}

\subsection{Dealing with type families}
To address these problems, we first need to consider a limitation with how type families work.
Consider the declaration
\begin{lstlisting}
newtype Wrap (t::Type->Type) a = Wrap (t a)
\end{lstlisting}
The list constructor |[]| has kind |Type->Type|,
so we can create an expression like
\begin{lstlisting}
Wrap [1] :: Wrap [] Int
\end{lstlisting}
The |Scalar| type family also has kind |Type->Type|,
so we would like to use it similarly.
\begin{lstlisting}
Wrap 1 :: Wrap Scalar (Vec3 Int)
\end{lstlisting}
Unfortunately, this expression does not type check because GHC requires that type families be fully applied anywhere they appear in a type signature.
In this section, we will create a workaround that allows us to pass type families as arguments to types.\footnote{
    The {\ttfamily singletons} package provides a similar construction in Section 4.3 of the related paper \cite{eisenbarg2015promoting}.
    The {\ttfamily singletons}' construction is more general in order to allow for the promotion of ordinary functions to type families, and is therefore more complicated.
    For ease of presentation, we do not use their construction.
}

The first step is to create a new data type for each type family.
The naming convention used by \homoiconic is to put a |T| in front of the family's name.
For example, we declare
\begin{lstlisting}
data TScalar
\end{lstlisting}
for the type family |Scalar|.
We call types created in this way ``tags,''
and create the following type synonym to refer to them.
\begin{lstlisting}
type Tag = Type
\end{lstlisting}
We would get more type safety if |Tag| were introduced as a new kind distinct from |Type|;
but this requires open kinds, which is a feature not yet available in GHC.\footnote{
    Issue \#11080 on GHC Trac has an extensive discussion of this feature.
    See \url{https://ghc.haskell.org/trac/ghc/ticket/11080}.
}

Next, we need a way to apply the |TScalar| type as if it were a type family.
The |App| type class serves this role.
\begin{lstlisting}
type family App (t::Tag) (a::Type) :: Type
\end{lstlisting}
The |t| parameter is the tag representing the type family we want to apply,
and the |a| parameter is the type to which we want to apply the type family.
The |Scalar| instance looks like
\begin{lstlisting}
type instance App TScalar a = Scalar a
\end{lstlisting}
And now we can create a modified version of our |Wrap| type above that actually works.
\begin{lstlisting}
newtype Wrap2 (t::Tag) a = Wrap2 (AppTag t a)
\end{lstlisting}

Frequently, we will want to deal with not just a single type family application,
but a whole sequence of type family applications.
We can represent these applications with kind |[Tag]| as in the following family.
\begin{lstlisting}
type family AppTags (t::[Tag]) (a::Type) :: Type
type instance AppTags '[]       a = a
type instance AppTags (x ': xs) a
    = AppTag x (AppTags xs a)
\end{lstlisting}
Now we can create an even more powerful wrapper that can handle arbitrary applications of type families.
\begin{lstlisting}
newtype Wrap3 (t::[Tag]) a = Wrap3 (AppTags t a)
\end{lstlisting}

\subsection{Heterogeneous FAlgebras}

At last we are ready to see our type class for heterogeneous FAlgebras.
\begin{lstlisting}
class HetFunctor (Sig alg) => FAlgebra alg where
    data Sig alg (t::[Tag]) a

    runSig0 :: alg a => proxy a
        -> Sig alg t (AppTags t a)
        -> AppTags t a

    runSig1 :: alg a => proxy a
        -> Sig alg (s ': t) (AppTags t a)
        -> AppTags (s ': t) a
\end{lstlisting}
This class is considerably more complex looking than for homogeneous FAlgebras,
but it follows the same basic principles.
The most important difference is that the |Sig| data family has been given a new type parameter |t|.
This parameter tells us which type families have been applied to the variable |a|.
Exactly what this means will become more clear as we see how to create instances of |FAlgebra|.

First we discuss how to define instances of the |Sig| family.
We will need to use GADTs \cite{schrijvers2009complete} to ensure the |t| parameter is set correctly.
As before, the constructors can be classified as either function constructors or superclass constructors.
For function constructors, the parameters remain exactly the parameters of the function they correspond to.
The return type, however, depends on the return type of the function.
If the function's return type does not use a type family, then then the |t| parameter is |'[]|.
For example, the function constructor for |Vector|'s |(.*)| is
\begin{lstlisting}
Sig_dotmul :: Scalar a -> a -> Sig Vector '[] a
\end{lstlisting}
If the function's return type does use a type family, then the |t| parameter is the singleton list containing the family's tag.
For example, the function constructor for |Hilbert|'s |dotProduct| is
\begin{lstlisting}
Sig_dotProduct :: a -> a -> Sig Hilbert '[TScalar] a
\end{lstlisting}
Unlike functor constructors, superclass constructors are parametric in their |t| parameter.
Superclass constructors take a single parameter,
which is the |Sig| of the superclass.
If the corresponding constraint does not involve a type family,
then the |t| parameter is the same for the superclass and the returned value.
For example, the |Num a| constraint in the |Vector| instance gets the constructor
\begin{lstlisting}
Sig_Vector_Num :: Sig Num t a -> Sig Vector t a
\end{lstlisting}
If the class constraint does involve a type family,
then we prepend the type family's tag to |t| in the constructor's return type.
For example, the |Floating a| constraint in the |Vector| instance gets the constructor
\begin{lstlisting}
Sig_Vector_Floating_Scalar
    :: Sig Floating t a -> Sig Vector (TScalar ': t) a
\end{lstlisting}
These changes to the |Sig| type are the core of the differences between heterogeneous and homogeneous |FAlgebra|s.
There will be many changes to all of the other functions,
but they all stem from adapting the same techniques used in the homogeneous case to the modified |Sig|.

The |runSig| function has been split into two functions:
|runSig0| is for running functions that do not involve type families,
and |runSig1| is for running functions that involve a single type family.
|runSig0| works just like the homogeneous |runSig|,
but has a more complicated type signature due to the addition of the |t| parameter to |Sig|.
Recall that the |t| type variable represents the type families that have already been applied to the content of the |Sig|.
So when we run the |Sig|, the content needs to reflect those applications.
Thus, the parameter to |runSig0| is |Sig alg t (App t a)|.
Similarly, the return type needs to reflect those applications,
and so the return type is |Sig alg t (App t a)|.
Because the |a| type variable appears only inside type family applications,
we need the |proxy a| argument to avoid an ambiguous type.
To implement the |runSig0| function, function constructors get |runSig0| called recursively (with an appropriate |Proxy| parameter representing the type family application in the constraint);
type 0 function constructors are evaluated exactly as in the homogeneous case,
and type 1 function constructors are not evaluated at all since there's no way to make them type check.
For example, here is |Vector|'s |runSig0| function
\begin{lstlisting}
runSig0 _ (Sig_Vector_Num s)
    = runSig0 (Proxy::Proxy a) s
runSig0 _ (Sig_Vector_Floating s)
    = runSig0 (Proxy::Proxy (Scalar a)) s
runSig0 _ (Sig_dotmul s a) = s.*a
\end{lstlisting}
and |Hilbert|'s |runSig0| function
\begin{lstlisting}
runSig0 _ (Sig_Hilbert_Vector s)
    = runSig0 (Proxy::Proxy a) s
\end{lstlisting}
The return type of |runSig1| contains an extra |Tag| applied to it that the content of |Sig| does not have.
This lets us evaluate type 1 functions.
To implement |runSig1|, function constructors get called recursively as before,
but this time for only type 1 functions can be evaluated,
and type 2 functions will be ignored.
Here are the |runSig1| functions for |Vector| and |Hilbert|.
\begin{lstlisting}
runSig1 _ (Sig_Vector_Num s)
    = runSig0 (Proxy::Proxy a) s
runSig1 _ (Sig_Vector_Floating s)
    = runSig0 (Proxy::Proxy (Scalar a)) s

runSig1 _ (Sig_Hilbert_Vector s)
    = runSig1 (Proxy::Proxy a) s
runSig1 _ (Sig_dotproduct a1 a2) = dotproduct a1 a2
\end{lstlisting}
The last component of the |FAlgebra| is the |HetFunctor| class.
This class is used for evaluating the |AST|s and is discussed in Section \ref{sec:heteval}.
Before we get to that,
we'll discuss how to construct and show the ASTs.

\subsection{Constructing the AST}

To construct an AST out of the |Sig| functor requires a heterogeneous version of the free monad.
Like the |Sig| type, the heterogeneous free monad will carefully track the |t| parameter and so must be a GADT.
\begin{lstlisting}
data Free (f::[Tag]->Type->Type) (t::[Tag]) a where
  Free1::f (s ':t)(Free f t a)->Free f (s ':t) a
  Free0::f      t (Free f t a)->Free f      t  a
  Pure ::App t a -> Free f t a
\end{lstlisting}
There are now three constructors.
The |Free| and |Pure| constructors work exactly as they did before.
The only difference is that |Pure| does not store the |a| type inside of it,
but instead it applies the |t| type families to |a|.
The |FreeTag| constructor represents a branch like the |Free| constructor,
but it also represents a change in return type.
When embedding a |Sig| into an AST,
we will use the |FreeTag| constructor whenever the function's return type uses a type family.

The AST is then defined as
\begin{lstlisting}
type AST alg t a = Free (Sig alg) t a
\end{lstlisting}

We can make the AST type instances of the type classes similarly to how we did for homogeneous FAlgebras.
The main difference is that we will need a new |View| class for converting between |Sig|s.
This |View| class not only converts the |alg| parameter, but also the |t| parameter.
\begin{lstlisting}
class (FAlgebra alg1, FAlgebra alg2)
    => View alg1 t1 alg2 t2 where
    embedSig
        :: Sig alg1 t1 a -> Sig alg2 t2 a
    unsafeExtractSig
        :: Sig alg2 t2 a -> Sig alg1 t1 a
\end{lstlisting}

%\begin{lstlisting}
%embedSigTag :: View alg1 (t ': t1) alg2 (t ': t2) => Sig alg1 (t ': t1) a -> Sig alg2 (t ': t2) a
%embedSigTag = embedSig
%\end{lstlisting}

\subsection{Showing the AST}

To convert the heterogeneous AST into a |String|,
we need a |Show| instance for each |Sig| and a |Show| instance for |Free|.

The |Show| instance for the |Sig| type follows the same pattern as before.
For each function constructor,
simply show the constructor's arguments connected in an appropriate way by the function's name.
For each superclass constructor, show the contained constructor.
|Vector|'s show instance is given below.
\begin{lstlisting}
instance
    ( Show a
    , Show (Scalar a)
    ) => Show (Sig Vector t a)
        where
    show (Sig_Vector_Num s) = show s
    show (Sig_Vector_Floating s) = show s
    show (Sig_dotmul a1 a2) = show a1++".*"++show a2
\end{lstlisting}
Notice that we had to add the |Show (Scalar a)| constraint above because the |a1| variable in the last line has type |Scalar a|.

This instance can be defined, but it can't yet be used.
Recall that we defined
\begin{lstlisting}
type Scalar (AST alg t a) = AST alg (TScalar ': t) a
\end{lstlisting}
This means that when we call |show| on an |AST|,
the constraint solver will try to satisfy the |Show (Scalar a)| with the exact same instance.
In order to satisfy that constraint, we will need |Show (Show (Scalar a))|;
and to satisfy that, we need |Show (Scalar (Scalar (Scalar a)))|.
This nesting of |Scalar| type families continues forever,
and the constraint solver loops!

One solution to this problem is to add the following overlapping instance.
\begin{lstlisting}
instance {-#OVERLAPS#-} Show
    (Sig Module (t1 ': t2 ': t3 ': ts) a) where
    show _ = "<<overflow>>"
\end{lstlisting}
Once there are at least three |Scalar|s applied to |Show|'s parameter,
this new instance becomes more specific,
and is thus selected by GHC.
Since this instance has no constraints,
that ends the recursion.

We must perform a related type hack to get the |Show| instance for |Free|.
The |Show| instance for |Free| is shown below.
\begin{lstlisting}
instance
    ( Show      (App t a)
    , Show      (f t (Free f t a))
    , ShowUntag (f t (Free f t a))
    ) => Show (Free f t a)
        where
    show (FreeTag     f) = "("++show f++")"
    show (Free        f) = "("++show f++")"
    show (Pure        a) = show a

type family ShowUntag (f::Type) :: Constraint where
    ShowUntag (f (s ':  t) (Free f (s ':  t) a))  = Show (f (s ':  t) (Free f          t  a))
    ShowUntag a = ()
\end{lstlisting}
The |FreeTag| constructor must be undressed in order to satisfy the |Show| requirement.

\subsection{Evaluating the AST}
\label{sec:heteval}

Running the heterogeneous AST is almost the same as the homogeneous case.
\begin{lstlisting}
eval :: forall alg t a.
    ( FAlgebra alg
    , alg a
    ) => Free (Sig alg) t a -> App t a
eval (Pure    a) = a
eval (Free    s) = runSig0 (Proxy::Proxy a) $ mape eval s
eval (FreeTag s) = runSig1 (Proxy::Proxy a) $ mape eval s
\end{lstlisting}
The only difference is we need to add a line for the |FreeTag| parameter,
and we need to manually specify the type |a| with the |Proxy|.

\subsection{Heterogeneous homoiconicity at last!}

\section{Conclusion}

There are two more points worth discussion.

The first is efficiency.
The |stabilize| function is absurdly slow.
If you view the core, you can see two very different outputs.
But the output of |stabilize| is highly structured and ready to be optimized.
It's left as an exercise for the reader to write a GHC plugin to fix the problem.

The second is improved class hierarchies.
Most of the interesting alternative numeric hierarchies involve many non-homogeneous functions.
In particular, they use type classes.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\appendix
%\section{Appendix Title}
%
%This is the text of the appendix, if you need one.
%Most notably, it is not generic.
%
%\acks
%
%Acknowledgments, if needed.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{abbrvnat}
\bibliography{paper}


\end{document}
