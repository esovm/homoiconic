%-----------------------------------------------------------------------------
%
%               Template for sigplanconf LaTeX Class
%
% Name:         sigplanconf-template.tex
%
% Purpose:      A template for sigplanconf.cls, which is a LaTeX 2e class
%               file for SIGPLAN conference proceedings.
%
% Guide:        Refer to "Author's Guide to the ACM SIGPLAN Class,"
%               sigplanconf-guide.pdf
%
% Author:       Paul C. Anagnostopoulos
%               Windfall Software
%               978 371-2316
%               paul@windfall.com
%
% Created:      15 February 2005
%
%-----------------------------------------------------------------------------


\documentclass[preprint]{sigplanconf}

% The following \documentclass options may be useful:

% preprint      Remove this option only once the paper is in final form.
% 10pt          To set in 10-point type instead of 9-point.
% 11pt          To set in 11-point type instead of 9-point.
% numbers       To obtain numeric citation style instead of author/year.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{amsmath}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{amsthm}
\makeatletter
\def\th@definition{%
  \thm@notefont{}% same as heading font
  \normalfont % body font
}
\makeatother
\theoremstyle{definition}
\newtheorem{problem}{Problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\usepackage{courier}
\usepackage{listings}
\lstset{
    language=Haskell,
    basicstyle=\ttfamily\footnotesize,
    keywordstyle=\ttfamily\footnotesize,
    %basicstyle=\footnotesize,
    literate={->}{{$\rightarrow$}}2 {>=}{{$\geq$}}2 {<-}{{$\leftarrow$}}2
             {<=}{{$\leq$}}2 {=>}{{$\Rightarrow$}}2
    %keywordstyle=\lst@ifdisplaystyle\color{blue}\fi,
    %commentstyle=\color{gray}
}
\lstMakeShortInline|

\newcommand{\cL}{{\cal L}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{filecontents}{paper.bib}
@article{goldberg1991,
  title={What every computer scientist should know about floating-point arithmetic},
  author={Goldberg, David},
  journal={ACM Computing Surveys (CSUR)},
  volume={23},
  number={1},
  pages={5--48},
  year={1991},
  publisher={ACM}
}

@book{higham2002,
  title={Accuracy and stability of numerical algorithms},
  author={Higham, Nicholas J},
  year={2002},
  publisher={Siam}
}

@article{swierstra2008,
  title={Data types {\`a} la carte},
  author={Swierstra, Wouter},
  journal={Journal of functional programming},
  volume={18},
  number={04},
  pages={423--436},
  year={2008},
  publisher={Cambridge Univ Press}
}

@book{hamming2012,
  title={Numerical methods for scientists and engineers},
  author={Hamming, Richard},
  year={2012},
  publisher={Courier Corporation}
}

@inproceedings{gupta2015,
  title={Deep Learning with Limited Numerical Precision},
  author={Gupta, Suyog and Agrawal, Ankur and Gopalakrishnan, Kailash and Narayanan, Pritish},
  booktitle={Proceedings of the 32nd International Conference on Machine Learning (ICML-15)},
  pages={1737--1746},
  year={2015}
}
\end{filecontents}
\immediate\write18{bibtex paper}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{document}

\special{papersize=8.5in,11in}
\setlength{\pdfpageheight}{\paperheight}
\setlength{\pdfpagewidth}{\paperwidth}

\conferenceinfo{CONF 'yy}{Month d--d, 20yy, City, ST, Country}
\copyrightyear{20yy}
\copyrightdata{978-1-nnnn-nnnn-n/yy/mm}
\copyrightdoi{nnnnnnn.nnnnnnn}

% Uncomment the publication rights you want to use.
%\publicationrights{transferred}
%\publicationrights{licensed}     % this is the default
%\publicationrights{author-pays}

\titlebanner{Preprint}        % These are ignored unless
\preprintfooter{Preprint}   % 'preprint' option specified.

%\title{What's the point of homoiconicity?}
%\title{The (floating) point of homoiconicity}
\title{Homoiconicity Without Template Haskell}
\subtitle{Functional Pearl}

\authorinfo{Mike Izbicki}
           {UC Riverside}
           {mike@izbicki.me}
%\authorinfo{Name2\and Name3}
           %{Affiliation2/3}
           %{Email2/3}

\maketitle

\begin{abstract}
We say a function is \emph{homoiconic} if it can be converted into an isomorphic abstract syntax tree (AST),
and the resulting AST can be converted back into the original function.
Homoiconicity is a useful property because it lets libraries implement arbitrary program transformations on these functions by manipulating the AST.
This pearl shows that many Haskell functions are homoiconic.
The technique does not rely on template Haskell,
and so works on expressions available at either compile or run time.
To motivate this homoiconicity,
we construct a small library that automatically transforms numerically unstable code into stable code.

%This pearl shows that many Haskell functions are \emph{homoiconic}.
%That is, we can convert these functions into isomorphic abstract syntax trees (ASTs),
%and these ASTs can be converted back into their original Haskell functions.
%%These ASTs are ordinary Haskell data types,
%%so they can be manipulated arbitrarily to perform program transformations.
%The construction does not require template Haskell,
%and so works on expressions available at either compile or run time.
%To motivate this homoiconicity,
%we construct a small library that automatically transforms numerically unstable code into stable code.

%Floating point numbers are dangerous.
%Due to their limited precision,
%seemingly correct mathematical formulae can give wildly inaccurate results.
%This pearl shows that Haskell's type system can mitigate this danger.
%
%The main observation is that many numerical Haskell functions are \emph{homoiconic}.
%That is, we can easily convert them into isomorphic abstract syntax trees (ASTs).
%The construction does not use template Haskell, and so works at both compile and run time.
%We will use these ASTs to solve two problems with floating point numbers:
%\begin{enumerate}
%\item
%We will write higher order functions that automatically stabilize (or optimize!) mathematical formulae.
%%This lets one programmer write naive floating point code;
%%then an expert on numerical analysis can write code that automatically improves the naive code.
%\item
%We will specify type class laws for floating point arithmetic that can be automatically tested.
%Existing test frameworks do not work on floating point numbers because floats do not obey many traditional algebraic laws like associativity.
%\end{enumerate}
%We demonstrate these techniques using GHC's built-in numeric class hierarchy,
%but these techniques generalize to user defined class hierarchies as well.
\end{abstract}

%\category{CR-number}{subcategory}{third-level}

% general terms are not compulsory anymore,
% you may leave them out
%\terms
%term1, term2

%\keywords
%floating point, homoiconic, type classes

\section{Introduction}

Imagine you're writing a machine learning library in Haskell.
%You decide to start by implementing logistic regression.
%The first step is to implement the log-logistic function
%Logistic regression is one of the most important machine learning algorithms,
%and to implement it, you'll need to implement the log-logistic function
%To implement the classic logistic regression algorithm,
%you begin by implementing the log-logistic function
At some point, you'll need to implement the log-logistic function
\begin{equation}
f(x) = \log\left(\frac{1}{1+\exp{(-x)}}\right)
\label{eq:log-logistic}
\end{equation}
This function is used in logistic regression and many families of neural networks.
As a first attempt, you might write:
\begin{lstlisting}
logLogistic1 :: Floating x => x -> x
logLogistic1 x = log(1/(1+exp(-x)))
\end{lstlisting}
Unfortunately, this straightforward implementation is numerically unstable.
When specialized to the |Double| type,
the |exp| function overflows to infinity for inputs greater than (approximately) $709$.
%This overflow causes |logLogistic| to take the |log| of 0, which is undefined.
Therefore, on an input of $-710$,
|logLogisitic| will take the |log| of 0,
returning negative infinity when the true answer is actually very close to $-710$.
Such an inaccurate answer is unacceptable,
so our function must be rewritten.

But like all good programmers, you're lazy.
Your machine learning library will contain thousands of numeric functions,
all of which will need to be carefully written to avoid numeric instabilities.
What a maintenance nightmare!
Soon you start daydreaming about a function
\begin{lstlisting}
stabilize :: Floating a => (a -> a) -> (a -> a)
\end{lstlisting}
that takes a naively written floating point function as input and outputs a numerically stable version.
Armed with such a function, you could write a stable implementation of the log-logistic function as
\begin{lstlisting}
logLogistic2 :: Floating x => x -> x
logLogistic2 x = stabilize $ log(1/(1+exp(-x)))
\end{lstlisting}
%stopzone

In this pearl, we see how to write functions like |stabilize|.
The key observation is that certain Haskell functions can be converted into an isomorphic abstract syntax tree (AST).
The |stabilize| function uses this fact to convert its input function into an AST;
manipulates that AST to remove numerical stabilities;
then converts the AST back into a callable function.

In Section \ref{sec:homogeneous}, we introduce the idea of a \emph{homogeneous} function and show that these functions are homoiconic.
In Section \ref{sec:stabilize}, we use the construction above to implement several versions of the |stabilize| function.
In Section \ref{sec:heterogeneous}, we introduce the idea of \emph{heterogeneous} functions and show that they are also homoiconic.
Finally, we conclude by introducing a Haskell package called {\ttfamily homoiconic} that makes it easy for you to .

\section{Homogeneous functions are homoiconic}
\label{sec:homogeneous}
We call a function \emph{homogeneous} if:
\begin{enumerate}
\item
%The function's return type and all of its parameters are the same type variable.
The function is polymorphic in its return type.
\item
The function's parameters are either the same as the return type or they are concrete.
\item
The constraints contain exactly one type class, and
that type class has exactly one parameter,
which is the function's return type.
\end{enumerate}
The |logLogistic1| function is homogeneous.
Figure \ref{code:ghc} shows many more examples from GHC's numeric and ordering hierarchies.

In this section, we will show that every type class has an associated monad representing the abstract syntax tree of the class's homogeneous functions.
Our construction is closely related to other constructions involving initial algebras, FAlgebras, and free monads.
See for example \cite{swierstra2008}.

\begin{figure}
\begin{lstlisting}
class Num a where
    (+), (-), (*)       :: a -> a -> a
    negate              :: a -> a
    abs, signum         :: a -> a
    fromInteger         :: Integer -> a

class Num a => Fractional a where
    (/)                 :: a -> a -> a
    recip               :: a -> a
    fromRational        :: Rational -> a

class Fractional a => Floating a where
    pi                  :: a
    exp, log, sqrt      :: a -> a
    (**), logBase       :: a -> a -> a
    sin, cos, tan       :: a -> a
    asin, acos, atan    :: a -> a
    sinh, cosh, tanh    :: a -> a
    asinh, acosh, atanh :: a -> a

class Eq a where
    (==), (/=)          :: a -> a -> Bool

class Eq a => Ord a where
    compare             :: a -> a -> Ordering
    (<),(<=),(>),(>=)   :: a -> a -> Bool
    max, min            :: a -> a -> a
\end{lstlisting}
\caption{
    A portion of the numeric and comparison hierarchies defined in GHC's Prelude.
    %Functions highlighted in bold are homogeneous,
    %and the remainder are not.
}
\label{code:ghc}
\end{figure}

\subsection{A type class for FAlgebras}
FAlgebras are a technique used in the mathematical fields of universal algebra and category theory for defining algebraic structures.
We represent an FAlgebra with the following type class.
\begin{lstlisting}
class Functor (Sig alg) => FAlgebra alg where
    data Sig alg a
    runSig :: alg a => Sig alg a -> a
\end{lstlisting}
The |FAlgebra| class is unusual in that its parameter has kind |Type->Constraint|.
This means that instances of |FAlgebra| will be other type classes
(instead of types or type constructors).

It is easiest to understand instances of |FAlgebra| by walking through an example.
Below is the instance for |Fractional|.
\begin{lstlisting}
instance FAlgebra Fractional where
    data Sig Fractional a
        = Sig_div a a
        | Sig_recip a
        | Sig_fromRational Rational
        | Sig_Fractional_Num (Sig Num a)
    runSig (Sig_div a1 a2)        = a1/a2
    runSig (Sig_recip a)          = recip a
    runSig (Sig_fromRational r)   = fromRational r
    runSig (Sig_Fractional_Num s) = runSig s
\end{lstlisting}

The data family |Sig| encodes what mathematicians call the \emph{signature} of the FAlgebra.
The signature defines all the operations that can be performed on an FAlgebra.
Each |Sig| data instance can have many constructors,
which can be divided into two categories.
First, there should be one constructor for each homogeneous class function.
This constructor should have the same parameters as the function.
For the |Fractional| example, we've defined the three constructors |Sig_div|, |Sig_recip|, and |Sig_fromRational| for the three member functions |(/)|, |recip|, and |fromRational|.
Second, there should be a constructor for each superclass.
This constructor should store the |Sig| of the corresponding superclass.
For the |Fractional| example, we have the |Sig_Fractional_Num| constructor corresponding to the |Num| superclass.

The |runSig| class method gives us a way to evaluate any |Sig|.
For each function constructor, |runSig| should call the corresponding function.
For each superclass constructor, |runSig| recursively calls |runSig| on the superclass's |Sig|.

The F in FAlgebra comes from the fact that every signature is actually a functor.
In Haskell, we encode this by enforcing that |Sig alg| must be an instance of the |Functor| class in order to create a valid |FAlgebra| instance for |alg|.
As usual, there is only a single valid |Functor| instance.
For |Fractional|, it is:

\begin{lstlisting}
instance Functor (Sig Fractional) where
    fmap f (Sig_div a1 a2) = Sig_div (f a1) (f a2)
    fmap f (Sig_recip a) = Sig_recip (f a)
    fmap f (Sig_fromRational r) = Sig_fromRational r
    fmap f (Sig_Fractional_Num s) = fmap f s
\end{lstlisting}
As usual, there is only a single valid |Functor| instance.
There are multiple valid |Foldable| instances depending on the order in which |foldr| considers the constructors' parameters,
but for our purposes the order is not important.

\subsection{Constructing the AST}

For every FAlgebra, there is an associated AST with the corresponding algebraic structure.
This AST is sometimes called an \emph{initial algebra},
and has a standard construction via the \emph{free monad}.

In Haskell, the free monad is defined as
\begin{lstlisting}
data Free f a
    = Pure a
    | Free (f (Free f a))
\end{lstlisting}
which lets us define our AST as
\begin{lstlisting}
type AST alg a = Free (Sig alg) a
\end{lstlisting}
Intuitively,
the |Pure| constructor represents a leaf in the AST,
and the |Free| constructor represents a branch.
The parameter to |Free| is filled by the appropriate |Sig| data instance.
The constructor used for the |Sig| instance corresponds to an operation,
and the parameters to the constructor will contain ASTs nested recursively.

For example, consider the expression |(1+2)+3|.
We can create a corresponding AST using |Num|'s |FAlgebra| instance.
\begin{lstlisting}
Free
  (Sig_plus
    (Free
      (Sig_plus
        (Pure 1)
        (Pure 2)
      )
    )
    (Pure 3)
  )
\end{lstlisting}
We can also create a corresponding AST for any class that has |Num| as a superclass.
Below is the same expression encoded using |Floating|'s |FAlgebra| instance.
\begin{lstlisting}
Free
  (Sig_Floating_Fractional
    (Sig_Fractional_Num
      (Sig_plus
        (Free
          (Sig_Floating_Fractional
            (Sig_Fractional_Num
              (Sig_plus
                (Pure 1)
                (Pure 2)
              )
            )
          )
        )
        (Pure 3)
      )
    )
  )
\end{lstlisting}
Notice that the |Sig_plus| constructor must be embedded into |Floating|'s |Sig| with calls to |Sig_Floating_Fractional| and |Sig_Fractional_Num|.

Constructing these ASTs by hand is a tedious process.
There is a considerable amount of boilerplate in the |Floating| AST above as a result of the need to embed the |Sig_plus| constructor.
We can avoid this boilerplate with the following type class.
\begin{lstlisting}
class
    ( FAlgebra alg1
    , FAlgebra alg2
    ) => View alg1 alg2
        where
    embedSig         :: Sig alg1 a -> Sig alg2 a
    unsafeExtractSig :: Sig alg2 a -> Sig alg1 a
\end{lstlisting}
Instances of the |View| class should satisfy the property that |alg1| is either equal to |alg2| or is a superclass of |alg2|, and
all such relationships should have a corresponding instance.
For example, |Num| is a superclass of |Floating|,
so we should have a |View Num Floating| instance.
\begin{lstlisting}
instance View Num Floating
    embedSig s
        = Sig_Fractional_Floating (embedSig s)
    unsafeExtractSig (Sig_Fractional_Floating s)
        = unsafeExtractSig s
\end{lstlisting}
Because of this property, we know that the |Sig alg1 a| data instance can always be embedded into a |Sig alg2 a| data instance.
But it is only sometimes true that we can extract a |Sig alg1 a|,
which is why the corresponding function is labeled |unsafe|.

Armed with the |View| class, we can create a uniform representation for all class's ASTs.
The expression |(1+2)+3| can now be represented as:
\begin{lstlisting}
Free
  (embedSig
    (Sig_plus
      (Free
        (embedSig
          (Sig_plus
            (Pure 1)
            (Pure 2)
          )
        )
      )
      (Pure 3)
    )
  )
\end{lstlisting}

Using our uniform representation of an AST,
we can make the AST itself an instance of any |FAlgebra| type class.
Again, we'll approach the procedure by example.
We can write a |Num| instance for |AST Num a| as:
\begin{lstlisting}
instance View Num alg => Num (Free (Sig alg) a)
        where
    (+) e1 e2 = Free (embedSig (Sig_plus e1 e2))
\end{lstlisting}
For each function in the type class,
we simply embed the function's constructor into the AST by prepending the expression |Free $ embedSig $|.
The |Fractional| and |Floating| instances follow a similar pattern.

We can easily create ASTs using these instances.
The |Num| AST can be created with the expression
\begin{lstlisting}
(1+2)+3 :: AST Num a
\end{lstlisting}
And the |Floating| AST can be created by just changing the type signature.
\begin{lstlisting}
(1+2)+3 :: AST Floating a
\end{lstlisting}

\subsection{Showing the AST}
Now that we can create our ASTs, we want to actually do something with them!
The simplest task is to convert them into a |String| for display.
This is an easy procedure of writing |Show| instances for the |Sig| and |Free| data types.

The are no tricks in the |Show| instance for the |Sig| instance.
The instance for |Fractional| is shown below.
\begin{lstlisting}
instance Show a => Show (Sig Fractional a) where
    show (Sig_div a1 a2) = show a1++"/"++show a2
    show (Sig_recip a) = "recip "++show a
    show (Sig_fromRational r) = "fromRational "++show r
    show (Sig_Fractional_Num s) = show s
\end{lstlisting}
For each function constructor, we simply show the corresponding function and its parameters.
If the function is an operator, we'll display it infix for convenience.
For each superclass constructor, we simply recursively call show on the superclass's |Sig|.

The |Free| type's |Show| instance is similarly straightforward.
\begin{lstlisting}
instance (Show a, Show (f (Free f a)))
    => Show (Free f a)
        where
    show (Pure a) = show a
    show (Free f) = "("++show f++")"
\end{lstlisting}
If the syntax tree contains only a single leaf, we just show that leaf.
If the syntax tree contains a branch,
then put parenthesis around the branch so that we don't lose information about the order of operations, and show the functor in the middle.

Now, when we type an expression into ghci,
\begin{lstlisting}
ghci> (1+2)+3
6
ghci> (1+2)+3 :: AST Floating Int
(1+2)+3
\end{lstlisting}

\subsection{Evaluating the syntax tree}
Another useful task for ASTs is to evaluate them,
generating the value they represent.
To do this, we will take advantage of the free monad's structure.
The free monad is so called because as long as the parameter |f| is a |Functor|,
then |Free| has a valid |Monad| instance.
Since all |Monad|s are by necessity also |Functor|s,
|Free| has a valid |Functor| instance as well.
\begin{lstlisting}
instance Functor f => Functor (Free f) where
    fmap g (Pure a) = Pure (g a)
    fmap g (Free f) = Free (fmap (fmap g) f)
\end{lstlisting}
For our purposes, that's all the structure we'll need.

First, we construct a function that ``runs'' the syntax tree, converting it into a single value.
\begin{lstlisting}
runAST :: (FAlgebra alg, alg a) => AST alg a -> a
runAST (Pure a) = a
runAST (Free f) = runSig (fmap evalHom f)
\end{lstlisting}
If our syntax tree already consists of just a single value (i.e. it is the |ePure| constructor),
then we just return that value.
Otherwise, we use the |Functor| instance to recursively convert the |Sig|s into types of |a|, then a call to |runSig| combines the results.

\subsection{Homoiconicity at last!}
We are finally ready to see that our construction makes homogeneous functions homoiconic.
If we open GHCi and enter the following expression
\begin{lstlisting}
ghci> let ast=associator (Pure a1) (Pure a2) (Pure a3)
\end{lstlisting}
the display shows our AST
\begin{lstlisting}
\end{lstlisting}
We can also evaluate our AST and see that doing so gives the same results as running the original expression.
\begin{lstlisting}
ghci> runAST ast

ghci> associator a1 a2 a3

\end{lstlisting}
We are now ready to use our ASTs to make working with numeric functions easier.
%\subsection{The Prelude's Numeric Hierarchy}

\section{Implementing the stabilize function}
\label{sec:stabilize}

We've seen how to easily construct the ASTs,
now it's time to perform computations on them.
The standard way to deconstruct an AST is via pattern matching.
We'll use the |ViewPatterns| and |PatternSynonyms| language extensions to simplify this task.
Then we'll see three examples of improving floating point accuracy.

\subsection{Pattern matching the AST}

We'll begin with a very simple example.
Consider the following simple, but numerically unstable function.
\begin{lstlisting}
testFunc1 :: Floating a => a -> a
testFunc1 = log(exp a)
\end{lstlisting}
As in our |logLogistic1| function, |testFunc| is unstable when specialized to |Double|s
because input values greater than (approximately) 710 cause the |exp| function to overflow to infinity;
the log of infinity is still infinity;
so the returned answer is infinity.
But clearly this is not the correct answer.
Mathematically, the $\log$ is the inverse of $\exp$, so the final result should be 711.

First, we'll see how to properly manipulate the AST to fix this problem.
%We need a function of type |AST Floating a -> AST Floating a|.
We're trying to convert the expression |log (exp x)| into simply |x|.
To do this, we can just pattern match on the AST for the left hand side of the expression,
and replace it with the right hand side.
\begin{lstlisting}
logexpAST1 ::
    AST Floating a -> AST Floating a
logexpAST1
    (Free (Sig_log (Free (Sig_exp a)))) = a
logexpAST1 a = a
\end{lstlisting}
This function has two problems.
First, our pattern matching expression is large and obnoxious.
Second, it's not generic.

We can fix the second problem using the |ViewPatterns| language extension.
\begin{lstlisting}
logexpAST2 :: View Floating alg
    => AST alg a -> AST alg a
logexpAST2
    (Free (unsafeExtractSig -> Sig_log
    (Free (unsafeExtractSig -> Sig_exp a))))
    = a
logexpAST2 a = a
\end{lstlisting}
But this made our pattern matches even uglier!
Fortunately, we can use the |PatternSynonyms| extension to greatly simplify these patterns.
\footnote{
    %These patterns can be made bidirectional using the |embedSig| function.
    For ease of presentation, only the unidirectional case is shown.
}
\begin{lstlisting}
pattern AST_log ::
    ( View Floating alg
    ) => AST alg a -> AST alg a
pattern AST_log e
    <- Free (unsafeExtractSig -> Sig_log e)

pattern AST_exp ::
    ( View Floating alg
    ) => AST alg a -> AST alg a
pattern AST_exp e
    <- Free (unsafeExtractSig -> Sig_exp e)
\end{lstlisting}
Armed with these pattern synonyms, we can rewrite our function in the much simpler form below.
\begin{lstlisting}
logexpAST3 :: View Floating alg
    => AST alg a -> AST alg a
logexpAST3 (AST_log (AST_exp a)) = a
logexpAST3 a = a
\end{lstlisting}
Now that we can manipulate the AST, let's apply it to our function.
\begin{lstlisting}
transform1 :: forall alg x.
    ( FAlgebra alg
    , alg x
    ) => (AST alg x -> AST alg x)
      -> (AST alg x -> AST alg x)
      -> (x -> x)
transform1 go f x = runAST $ go $ f (Pure x)
\end{lstlisting}


But is our function really correct?
\begin{lstlisting}
testFunc2 :: Floating a => a -> a
testFunc2 = 1+log(exp a)
\end{lstlisting}
What if we call

\begin{lstlisting}
logexpAST4 :: View Floating alg => AST alg a -> AST alg a
logexpAST4 (AST_log (AST_exp a)) = a
logexpAST4 (Free f) = Free (fmap logexpAST4 f)
logexpAST4 (Pure a) = Pure a
\end{lstlisting}

\begin{lstlisting}
testFunc :: Floating a => a -> a
testFunc a = log(exp a)

ghci> logexpAST4 (testFunc 2) :: AST Floating Double
((fromInteger 1)+(fromInteger 2))

testFunc2 :: Floating a => a -> a
testFunc2 a = 1+exp(exp(exp(log(log(log a)))))

ghci> fixAST stabilizeAST
    (testFunc2 var1 :: AST Floating Var)
((fromInteger 1)+var1)
\end{lstlisting}

\begin{lstlisting}
fixAST :: (Eq (Sig alg (Free (Sig alg) a)), Eq a) => (AST alg a -> AST alg a) -> AST alg a -> AST alg a
fixAST f ast = if ast==ast'
    then ast
    else fixAST f ast'
    where
        ast' = f ast
\end{lstlisting}

\subsection{More complex rules}

The rules in in the previous section are relatively simple.
They could just as easily have been written using GHC's rewrite rules syntax.
Rewrite rules are the primary mechanism for optimising source code in GHC.
One optimization that rewrite rules cannot support is constant folding,
and there is code in GHC specially to perform this constant folding.

\begin{lstlisting}
foldConstants :: View Num alg => AST alg a -> AST alg a
foldConstants (AST_plus   (AST_fromInteger a1) (AST_fromInteger a2)) = AST_fromInteger (a1+a2)
foldConstants (AST_minus  (AST_fromInteger a1) (AST_fromInteger a2)) = AST_fromInteger (a1-a2)
foldConstants (AST_mul    (AST_fromInteger a1) (AST_fromInteger a2)) = AST_fromInteger (a1*a2)
foldConstants (AST_negate (AST_fromInteger a1)) = AST_fromInteger (negate a1)
foldConstants (Free sig) = Free (fmap foldConstants sig)
foldConstants (Pure a  ) = Pure a
\end{lstlisting}

\begin{lstlisting}
constExpr :: Num a => a
constExpr = 4+2*(8-2)-1

-- ghci> fixAST foldConstants constExpr
-- (fromInteger 18)

constFunc :: Num a => a -> a -> a
constFunc x1 x2 = x1*2-(7-2)*x2

-- ghci> fixAST foldConstants (constFunc 2 3)
-- (fromInteger -11)
-- ghci> fixAST foldConstants (constFunc var1 var2)
-- ((var1*(fromInteger 2))-((fromInteger 5)*var2))
\end{lstlisting}

\subsection{The log-logistic function}

\begin{lstlisting}
stabAST :: Eq a =>
    AST FloatingOrd a -> AST FloatingOrd a
stabAST
    (AST_log
        (AST_div
            (AST_fromInteger 1)
            (AST_plus
                (AST_fromInteger 1)
                (AST_exp
                    (AST_negate x)
                )
            )
        )
    )
    = logLogistic2 x
\end{lstlisting}

\section{Heterogeneous functions are homoiconic}

%\begin{lstlisting}
%data Vec3 a = Vec3 a a a
    %deriving (Eq,Show)
%\end{lstlisting}

One of the main limitations of GHC's numeric hierarchy is that it was designed for scalar numbers.
A logistic regression implementation needs vectors.
There's been many proposals to extend GHC's built-in hierarchy to handle vectors.
A very simple such extension is shown in Figure \ref{code:vector}.
This extension uses type families.

\begin{figure}
\begin{lstlisting}
type family Scalar a

class (Num a, Fractional (Scalar a)) => Vector a where
    (.*) :: Scalar a -> a -> a

class Vector a => Hilbert a where
    dotproduct :: a -> a -> Scalar a
\end{lstlisting}
\caption{
    A simple extension to GHC's numeric hierarchy for vector arithmetic.
}
\label{code:vector}
\end{figure}

\begin{lstlisting}
logLoss :: Vector a => a -> a -> Scalar a
logLoss a1 a2 = logLogistic1 (dotproduct a1 a2)
\end{lstlisting}

The |logLoss|, |(.*)|, and |dotProduct| functions are not homogeneous because of the type families.
Heterogeneous functions are a relaxation of homogeneous functions.
We call a function \emph{heterogeneous} if:
\begin{enumerate}
\item
The function is polymorphic in its return type.
\item
The function's parameters are either the same as the return type, they are concrete.
\item
The constraints contain exactly one type class, and
that type class has exactly one parameter,
which is the function's return type.
\end{enumerate}

\subsection{Dealing with type families}

\begin{lstlisting}
type AT = Type
\end{lstlisting}

\begin{lstlisting}
type family App (t::k) (a::Type) ::  Type
type instance App '[]       a = a
type instance App (x ': xs) a = App x (App xs a)
\end{lstlisting}

\subsection{Heterogeneous FAlgebras}

\begin{lstlisting}
class FunctorTag (f::[AT]->Type->Type) where
    fmapTag :: HaskTag a b -> f t a -> f t b
\end{lstlisting}

\begin{lstlisting}
class HetFunctor (Sig alg) => FAlgebra (alg::Type->Constraint) where
    data Sig alg (t::[AT]) a

    runSigTag :: alg a => proxy a -> Sig alg (s ':  t) (App t a) -> App (s ':  t) a
    runSig    :: alg a => proxy a -> Sig alg        t  (App t a) -> App        t  a
\end{lstlisting}

\subsection{Constructing the AST}

\begin{lstlisting}
type AST alg t a = Free (Sig alg) t a

data Free (f::[AT]->Type->Type) (t::[AT]) (a::Type) where
    FreeTag  :: f (s ': t) (Free f t a)  -> Free f (s ': t) a
    Free     :: f       t  (Free f t a)  -> Free f       t  a
    Pure     :: App t a -> Free f t a
\end{lstlisting}

\begin{lstlisting}
class (FAlgebra alg1, FAlgebra alg2) => View alg1 t1 alg2 t2 where
    embedSig          :: Sig alg1       t1  a -> Sig alg2       t2  a
    unsafeExtractSig  :: Sig alg2       t2  a -> Sig alg1       t1  a
\end{lstlisting}

\begin{lstlisting}
embedSigTag :: View alg1 (t ': t1) alg2 (t ': t2) => Sig alg1 (t ': t1) a -> Sig alg2 (t ': t2) a
embedSigTag = embedSig
\end{lstlisting}

\subsection{Showing the AST}

\begin{lstlisting}
instance
    ( Show      (App t a)
    , Show      (f t (Free f t a))
    , ShowUntag (f t (Free f t a))
    ) => Show (Free f t a)
        where
    show (FreeTag     f) = "("++show f++")"
    show (Free        f) = "("++show f++")"
    show (Pure        a) = show a

type family ShowUntag (f::Type) :: Constraint where
    ShowUntag (f (s ':  t) (Free f (s ':  t) a))  = Show (f (s ':  t) (Free f          t  a))
    ShowUntag a = ()
\end{lstlisting}

\subsection{Evaluating the AST}

\begin{lstlisting}
eval :: forall alg t a.
    ( FAlgebra alg
    , alg a
    ) => Free (Sig alg) t a -> App t a
eval (Pure    a) = a
eval (Free    s) = runSig    (Proxy::Proxy a) $ mape eval s
eval (FreeTag s) = runSigTag (Proxy::Proxy a) $ mape eval s
\end{lstlisting}

\subsection{Heterogeneous homoiconicity at last!}

\section{Conclusion}

There are two more points worth discussion.

The first is efficiency.
The |stabilize| function is absurdly slow.
If you view the core, you can see two very different outputs.
But the output of |stabilize| is highly structured and ready to be optimized.
It's left as an exercise for the reader to write a GHC plugin to fix the problem.

The second is improved class hierarchies.
Most of the interesting alternative numeric hierarchies involve many non-homogeneous functions.
In particular, they use type classes.


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

%\appendix
%\section{Appendix Title}
%
%This is the text of the appendix, if you need one.
%Most notably, it is not generic.
%
%\acks
%
%Acknowledgments, if needed.
%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\bibliographystyle{abbrvnat}
\bibliography{paper}


\end{document}
